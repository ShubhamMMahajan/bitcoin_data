install.packages("pgmm")
install.packages("ElemStatLearn")
library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
library(rpart)
library(pgmm)
library(ElemStatLearn)
colnames(segmentationOriginal)
intrain <- createDataPartition(y = segmentationOriginal$Case, p = 0.7, list = F)
training <- segmentationOriginal[intrain,]
testing <- segmentationOriginal[-intrain,]
install.packages("e1071")
shiny::runApp('First')
trees
runApp('First')
View(car_data)
data("ChickWeight")
ChickWeight
runApp('First')
runApp('First')
runApp('First')
install.packages("googlevis")
install.packages("googleVis")
print("i")
Fruits
data(Fruits)
data(Fruits)
install.packages("plotly")
library(plotly)
plot_ly(mtcars, x = wt,  y = mpg, mode = "markers")
mtcars
library(plotly)
plot_ly(mtcars, x = mtcaras$wt,  y = mtcars$mpg, mode = "markers")
library(plotly)
plot_ly(mtcars, x = mtcars$wt,  y = mtcars$mpg, mode = "markers")
?plot_ly
library(googleVis)
Bubble <- gvisBubbleChart(Fruits, idvar="Fruit",
xvar="Sales", yvar="Expenses",
colorvar="Year", sizevar="Profit",
options=list(
hAxis='{minValue:75, maxValue:125}'))
plot(Bubble)
Pie <- gvisPieChart(CityPopularity)
plot(Pie)
require(datasets)
states <- data.frame(state.name, state.x77)
GeoStates <- gvisGeoChart(states, "state.name", "Illiteracy",
options=list(region="US",
displayMode="regions",
resolution="provinces",
width=600, height=400))
plot(GeoStates)
ChickWeight
plot_ly(ChickWeight, x = ChickWeight$Time, y = ChickWeight$weight, color = ChickWeight$Chick)
library(poltly)
plot_ly(ChickWeight, x = ChickWeight$Time, y = ChickWeight$weight, color = ChickWeight$Chick)
plot_ly(mtcars, x = mtcars$wt,  y = mtcars$mpg, mode = "markers")
library(googleVis)
library(plotly)
plot_ly(mtcars, x = mtcars$wt,  y = mtcars$mpg, mode = "markers")
library(googleVis)
Bubble <- gvisBubbleChart(Fruits, idvar="Fruit",
xvar="Sales", yvar="Expenses",
colorvar="Year", sizevar="Profit",
options=list(
hAxis='{minValue:75, maxValue:125}'))
plot(Bubble)
Pie <- gvisPieChart(CityPopularity)
plot(Pie)
require(datasets)
states <- data.frame(state.name, state.x77)
GeoStates <- gvisGeoChart(states, "state.name", "Illiteracy",
options=list(region="US",
displayMode="regions",
resolution="provinces",
width=600, height=400))
plot(GeoStates)
library(poltly)
plot_ly(ChickWeight, x = ChickWeight$Time, y = ChickWeight$weight, color = ChickWeight$Chick)
plot_ly(ChickWeight, x = ChickWeight$Time, y = ChickWeight$weight, color = ChickWeight$Chick)
View(tooth_data)
View(tooth_data)
plot_ly(tooth_data, x = tooth_data$dose, y = tooth_data$len, color = as.factor(tooth_data$supp))
Sys.setenv('SPARKR_SUBMIT_ARGS'='"--packages" "com.databricks:spark-csv_2.10:1.2.0" "sparkr-shell"')
library(SparkR, lib.loc = "C:\\Users\\shubh\\Documents\\Spark\\spark-2.2.0-bin-hadoop2.7\\R\\lib")
sc <- sparkR.init(master = "local", sparkHome = "C:\\Users\\shubh\\Documents\\Spark\\spark-2.2.0-bin-hadoop2.7\\R\\lib")
help("Deprecated")
sparkR.session()
bitcoin_price <- read.csv("bitcoin_price.csv")
setwd("C:\\Users\\shubh\\Documents\\Coursera\\kaggle")
bitcoin_price <- read.csv("/bitcoin_price.csv")
bitcoin_price <- read.csv("bitcoin_price.csv")
View(bitcoin_price)
View(bitcoin_price)
colnames(bitcoin_price)
bitcoin_price$Date <- as.Date(bitcoin_price$Date, format, tryFormats = (%m %d, %Y))
date_variable <- bitcoin_price$Date
date_variable<- as.Date(bitcoin_price$Date)
date_variable<- as.Date(bitcoin_price$Date, formalArgs("%m %d, %Y"))
date_variable<- as.Date(bitcoin_price$Date, format = "%m %d, %Y")
date_variable
date_variable<- as.Date(bitcoin_price$Date, format = "%b %d, %Y")
bitcoin_price$date<- as.Date(bitcoin_price$Date, format = "%b %d, %Y")
delete(date_variable)
rm(date_variable)
plot(x = bitcoin_price$Date, y = bitcoin_price$Open, type = "l")
?plot
plot(x = bitcoin_price$Date, y = bitcoin_price$Open, type = "b")
?open
?open
library(ggplot2)
# Basic line plot with points
ggplot(data=bitcoin_price, aes(x=bitcoin_price$Date, y=bitcoin_price$Open, group=1)) +
geom_line()+
geom_point()
library(ggplot2)
# Basic line plot with points
ggplot(data=bitcoin_price, aes(x=bitcoin_price$Date[1400,], y=bitcoin_price$Open[1400,], group=1)) +
geom_line()+
geom_point()
library(ggplot2)
# Basic line plot with points
ggplot(data=bitcoin_price, aes(x=bitcoin_price$Date[1400:], y=bitcoin_price$Open[1400:], group=1)) +
geom_line()+
geom_point()
ggplot(data=bitcoin_price, aes(x=bitcoin_price$Date[1400:length(bitcoin_price)], y=bitcoin_price$Open[1400:length(bitcoin_price)], group=1)) +
geom_line()+
geom_point()
library(ggplot2)
# Basic line plot with points
ggplot(data=bitcoin_price, aes(x=bitcoin_price$Date[1400:length(bitcoin_price)], y=bitcoin_price$Open[1400:length(bitcoin_price)], group=1)) +
geom_line()+
geom_point()
ggplot(data=bitcoin_price[1400:length(bitcoin_price)], aes(x=bitcoin_price$Date[1400:length(bitcoin_price)], y=bitcoin_price$Open[1400:length(bitcoin_price)], group=1)) +
geom_line()+
geom_point()
ggplot(data=bitcoin_price[1400:length(bitcoin_price),], aes(x=bitcoin_price$Date[1400:length(bitcoin_price)], y=bitcoin_price$Open[1400:length(bitcoin_price)], group=1)) +
geom_line()+
geom_point()
bitcoin_price[1400:length(bitcoin_price)]
bitcoin_price[1400:length(bitcoin_price),]
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point()
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(x = bitcoin_price$Date[1:200], y = "Price in $")
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_continuous(breaks=bitcoin_price$Date[1:200])
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(breaks=bitcoin_price$Date[1:200])
?scale_x_date
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(date_labels = "%b %d")
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(labels = date_format("%m-%Y"))
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(date_labels =  "%b %d")
?date_format
ggplot(data=bitcoin_price[1:200,], aes(x=bitcoin_price$Date[1:200], y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(labels =  "%b %d")
ggplot(data=bitcoin_price[1:200,], aes(x=as.Date(bitcoin_price$Date[1:200]), y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(labels =  "%b %d")
bitcoin_price$Date<- as.Date(bitcoin_price$Date, format = "%b %d, %Y")
library(ggplot2)
# Basic line plot with points
ggplot(data=bitcoin_price[1:200,], aes(x=as.Date(bitcoin_price$Date[1:200]), y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(labels =  "%b %d")
ggplot(data=bitcoin_price[1:200,], aes(x=as.Date(bitcoin_price$Date[1:200]), y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(labels = date_format("%b-%d"))
ggplot(data=bitcoin_price[1:200,], aes(x=as.Date(bitcoin_price$Date[1:200]), y=bitcoin_price$Open[1:200], group=1)) +
geom_line()+
geom_point() + labs(y = "Price in $") + scale_x_date(date_labels = "%b %d")
?plotly
?plot_ly
library(plotly)
?plot_ly
p <- plot_ly(bitcoin_price, x = ~bitcoin_price$Date, y = ~bitcoin_price$Open, name = 'Price in $', type = 'scatter', mode = 'lines')
p
Sys.Date()
format(Sys.Date(), %Y%m%d)
format(Sys.Date(), "%Y%m%d")
input <- "https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20130428&end=" +todays_date
todays_date = format(Sys.Date(), "%Y%m%d")
input <- "https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20130428&end=" +todays_date
toString(todays_date)
input <- "https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20130428&end=" +toString(todays_date)
input <- paste("https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20130428&end=", toString(todays_date))
input
txt <- htmlToText(input)
write(deparse(txt), "bitcoin.txt")
htmlToText <- function(input, ...) {
###---PACKAGES ---###
require(RCurl)
require(XML)
###--- LOCAL FUNCTIONS ---###
# Determine how to grab html for a single input element
evaluate_input <- function(input) {
# if input is a .html file
if(file.exists(input)) {
char.vec <- readLines(input, warn = FALSE)
return(paste(char.vec, collapse = ""))
}
# if input is html text
if(grepl("</html>", input, fixed = TRUE)) return(input)
# if input is a URL, probably should use a regex here instead?
if(!grepl(" ", input)) {
# downolad SSL certificate in case of https problem
if(!file.exists("cacert.perm")) download.file(url="http://curl.haxx.se/ca/cacert.pem", destfile="cacert.perm")
return(getURL(input, followlocation = TRUE, cainfo = "cacert.perm"))
}
# return NULL if none of the conditions above apply
return(NULL)
}
# convert HTML to plain text
convert_html_to_text <- function(html) {
doc <- htmlParse(html, asText = TRUE)
text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
return(text)
}
# format text vector into one character string
collapse_text <- function(txt) {
return(paste(txt, collapse = " "))
}
###--- MAIN ---###
# STEP 1: Evaluate input
html.list <- lapply(input, evaluate_input)
# STEP 2: Extract text from HTML
text.list <- lapply(html.list, convert_html_to_text)
# STEP 3: Return text
text.vector <- sapply(text.list, collapse_text)
return(text.vector)
}
txt_list <- unlist(strsplit(txt, "\n"))
txt <- htmlToText(input)
write(deparse(txt), "bitcoin.txt")
htmlToText <- function(input, ...) {
###---PACKAGES ---###
require(RCurl)
require(XML)
###--- LOCAL FUNCTIONS ---###
# Determine how to grab html for a single input element
evaluate_input <- function(input) {
# if input is a .html file
if(file.exists(input)) {
char.vec <- readLines(input, warn = FALSE)
return(paste(char.vec, collapse = ""))
}
# if input is html text
if(grepl("</html>", input, fixed = TRUE)) return(input)
# if input is a URL, probably should use a regex here instead?
if(!grepl(" ", input)) {
# downolad SSL certificate in case of https problem
if(!file.exists("cacert.perm")) download.file(url="http://curl.haxx.se/ca/cacert.pem", destfile="cacert.perm")
return(getURL(input, followlocation = TRUE, cainfo = "cacert.perm"))
}
# return NULL if none of the conditions above apply
return(NULL)
}
# convert HTML to plain text
convert_html_to_text <- function(html) {
doc <- htmlParse(html, asText = TRUE)
text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
return(text)
}
# format text vector into one character string
collapse_text <- function(txt) {
return(paste(txt, collapse = " "))
}
###--- MAIN ---###
# STEP 1: Evaluate input
html.list <- lapply(input, evaluate_input)
# STEP 2: Extract text from HTML
text.list <- lapply(html.list, convert_html_to_text)
# STEP 3: Return text
text.vector <- sapply(text.list, collapse_text)
return(text.vector)
}
txt_list <- unlist(strsplit(txt, "\n"))
txt <- htmlToText(input)
write(deparse(txt), "bitcoin.txt")
txt <- htmlToText(input)
txt
htmlToText <- function(input, ...) {
###---PACKAGES ---###
require(RCurl)
require(XML)
###--- LOCAL FUNCTIONS ---###
# Determine how to grab html for a single input element
evaluate_input <- function(input) {
# if input is a .html file
if(file.exists(input)) {
char.vec <- readLines(input, warn = FALSE)
return(paste(char.vec, collapse = ""))
}
# if input is html text
if(grepl("</html>", input, fixed = TRUE)) return(input)
# if input is a URL, probably should use a regex here instead?
if(!grepl(" ", input)) {
# downolad SSL certificate in case of https problem
if(!file.exists("cacert.perm")) download.file(url="http://curl.haxx.se/ca/cacert.pem", destfile="cacert.perm")
return(getURL(input, followlocation = TRUE, cainfo = "cacert.perm"))
}
# return NULL if none of the conditions above apply
return(NULL)
}
# convert HTML to plain text
convert_html_to_text <- function(html) {
doc <- htmlParse(html, asText = TRUE)
text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
return(text)
}
# format text vector into one character string
collapse_text <- function(txt) {
return(paste(txt, collapse = " "))
}
###--- MAIN ---###
# STEP 1: Evaluate input
html.list <- lapply(input, evaluate_input)
# STEP 2: Extract text from HTML
text.list <- lapply(html.list, convert_html_to_text)
# STEP 3: Return text
text.vector <- sapply(text.list, collapse_text)
return(text.vector)
}
txt <- htmlToText(input)
txt <- htmlToText(input)
write(deparse(txt), "Faculty_Information.txt")
htmlToText <- function(input, ...) {
###---PACKAGES ---###
require(RCurl)
require(XML)
###--- LOCAL FUNCTIONS ---###
# Determine how to grab html for a single input element
evaluate_input <- function(input) {
# if input is a .html file
if(file.exists(input)) {
char.vec <- readLines(input, warn = FALSE)
return(paste(char.vec, collapse = ""))
}
# if input is html text
if(grepl("</html>", input, fixed = TRUE)) return(input)
# if input is a URL, probably should use a regex here instead?
if(!grepl(" ", input)) {
# downolad SSL certificate in case of https problem
if(!file.exists("cacert.perm")) download.file(url="http://curl.haxx.se/ca/cacert.pem", destfile="cacert.perm")
return(getURL(input, followlocation = TRUE, cainfo = "cacert.perm"))
}
# return NULL if none of the conditions above apply
return(NULL)
}
# convert HTML to plain text
convert_html_to_text <- function(html) {
doc <- htmlParse(html, asText = TRUE)
text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
return(text)
}
# format text vector into one character string
collapse_text <- function(txt) {
return(paste(txt, collapse = " "))
}
###--- MAIN ---###
# STEP 1: Evaluate input
html.list <- lapply(input, evaluate_input)
# STEP 2: Extract text from HTML
text.list <- lapply(html.list, convert_html_to_text)
# STEP 3: Return text
text.vector <- sapply(text.list, collapse_text)
return(text.vector)
}
txt_list <- unlist(strsplit(txt, "\n"))
thepage = readLines(input)
thepage
dir.create(todays_date)
formatted_date = format(Sys.Date)
formatted_date
formatted_date
formatted_date = format(Sys.Date, "%b-%d-%Y")
formatted_date
formatted_date = format(Sys.Date(), "%b-%d-%Y")
dir.create(formatted_date)
setwd(paste(getwd(), "\\", formatted_date))
setwd(paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle", formatted_date))
setwd(paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle", formatted_date))
setwd(paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle\\", formatted_date))
getwd()
setwd("C:\\Users\\shubh\\Documents\\Coursera\\kaggle")
paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle\\", formatted_date)
paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle\\", formatted_date, sep = "")
setwd(paste("C:\\Users\\shubh\\Documents\\Coursera\\kaggle\\", formatted_date, sep = ""))
write(thepage, "bitcoin.txt")
txt_list <- unlist(strsplit(thepage, "\n"))
txt_list
grep("</tbody", txt_list)
start_of_data <- grep("<tbody>", txt_list) + 3
?gsub
library(qdapRegex)
rm_between(txt_list[560], '>', '>', extract=TRUE)[[1]]
library(qdap)
install.packages("qdap")
library(qdap)
genXtract(txt_list[560], "t\">", "</")
a = genXtract(txt_list[560], "t\">", "</")
a
print(a)
library(qdapRegex)
rm_between(txt_list[560], "t\">", "</", extract=TRUE)[[1]]
start_of_data <- grep("<tbody>", txt_list) + 3
end_of_data <- grep("/tbody", txt_list)
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
list_of_dates = c(list_of_dates, rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]]))
}
return(list_of_dates)
}
list_dates = find_date()
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
list_of_dates = c(list_of_dates, rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]])
}
return(list_of_dates)
}
list_dates = find_date()
list_dates
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
date_formatted = as.Date(rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]], format = "%b %d, %Y")
list_of_dates = c(list_of_dates, rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]])
}
return(list_of_dates)
}
list_dates = find_date()
list_dates
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
date_formatted = as.Date(rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]], format = "%b %d, %Y")
list_of_dates = c(list_of_dates, date_formatted)
}
return(list_of_dates)
}
list_dates = find_date()
list_dates
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
date_formatted = as.Date(rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]], format = "%b %d, %Y")
print(date_formatted)
list_of_dates = c(list_of_dates, date_formatted)
}
return(list_of_dates)
}
list_dates = find_date()
list_dates
find_date <- function() {
list_of_dates = list()
library(qdapRegex)
for(i in seq(from=start_of_data, to=end_of_data, by=10)){
list_of_dates = c(list_of_dates, rm_between(txt_list[i], "t\">", "</", extract=TRUE)[[1]])
}
return(list_of_dates)
}
list_dates = find_date()
list_dates
find_open <- function() {
list_of_open_price = list()
library(qdapRegex)
for(i in seq(from=start_of_data + 1, to=end_of_data, by=10)){
list_of_open_price = c(list_of_dates, rm_between(txt_list[i], "<td>", "</td>", extract=TRUE)[[1]])
}
return(list_of_open_price)
}
list_open_price = find_open()
find_open <- function() {
list_of_open_price = list()
library(qdapRegex)
for(i in seq(from=start_of_data + 1, to=end_of_data, by=10)){
list_of_open_price = c(list_of_open_price, rm_between(txt_list[i], "<td>", "</td>", extract=TRUE)[[1]])
}
return(list_of_open_price)
}
list_open_price = find_open()
list_open_price
find_high <- function() {
list_of_high_price = list()
library(qdapRegex)
for(i in seq(from=start_of_data + 2, to=end_of_data, by=10)){
list_of_high_price = c(list_of_high_price, rm_between(txt_list[i], "<td>", "</td>", extract=TRUE)[[1]])
}
return(list_of_high_price)
}
list_high_price = find_high()
list_high_price
